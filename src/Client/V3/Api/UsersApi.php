<?php declare(strict_types=1);
/*
 * FACT-Finder REST API Client
 * Copyright Â© webweit GmbH (https://www.webweit.de)
 */

/**
 * FACT-Finder REST-API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: V3
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.9
 */

namespace Web\FactFinderApi\Client\V3\Api;

use GuzzleHttp6\Client;
use GuzzleHttp6\Psr7\Request;
use GuzzleHttp6\RequestOptions;
use Web\FactFinderApi\Client\ApiClient;
use Web\FactFinderApi\Client\ObjectSerializer;
use Web\FactFinderApi\Client\V3\Model\Group;
use Web\FactFinderApi\Client\V3\Model\UserNoPassword;

/**
 * UsersApi Class Doc Comment
 *
 * @author   Swagger Codegen team
 *
 * @see     https://github.com/swagger-api/swagger-codegen
 */
class UsersApi extends ApiClient
{
    /**
     * Operation createGroupUsingPOST
     *
     * Create a new group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\Group
     */
    public function createGroupUsingPOST($group)
    {
        list($response) = $this->createGroupUsingPOSTWithHttpInfo($group);

        return $response;
    }

    /**
     * Operation createGroupUsingPOSTWithHttpInfo
     *
     * Create a new group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGroupUsingPOSTWithHttpInfo($group)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group';
        $request = $this->createGroupUsingPOSTRequest($group);

        return $this->executeRequest($request, $returnType);
    }

    /**
     * Operation createGroupUsingPOSTAsync
     *
     * Create a new group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function createGroupUsingPOSTAsync($group)
    {
        return $this->createGroupUsingPOSTAsyncWithHttpInfo($group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGroupUsingPOSTAsyncWithHttpInfo
     *
     * Create a new group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function createGroupUsingPOSTAsyncWithHttpInfo($group)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group';
        $request = $this->createGroupUsingPOSTRequest($group);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation createUserUsingPOST
     *
     * Create a new user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\User $user user (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\UserNoPassword
     */
    public function createUserUsingPOST($user)
    {
        list($response) = $this->createUserUsingPOSTWithHttpInfo($user);

        return $response;
    }

    /**
     * Operation createUserUsingPOSTWithHttpInfo
     *
     * Create a new user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\User $user user (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\UserNoPassword, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUserUsingPOSTWithHttpInfo($user)
    {
        $request = $this->createUserUsingPOSTRequest($user);

        return $this->executeRequest($request, UserNoPassword::class);
    }

    /**
     * Operation createUserUsingPOSTAsync
     *
     * Create a new user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\User $user user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function createUserUsingPOSTAsync($user)
    {
        return $this->createUserUsingPOSTAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUserUsingPOSTAsyncWithHttpInfo
     *
     * Create a new user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\User $user user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function createUserUsingPOSTAsyncWithHttpInfo($user)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword';
        $request = $this->createUserUsingPOSTRequest($user);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation deleteGroupUsingDELETE
     *
     * Delete a group
     *
     * @param string $name Name of the group which should be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\Group
     */
    public function deleteGroupUsingDELETE($name)
    {
        list($response) = $this->deleteGroupUsingDELETEWithHttpInfo($name);

        return $response;
    }

    /**
     * Operation deleteGroupUsingDELETEWithHttpInfo
     *
     * Delete a group
     *
     * @param string $name Name of the group which should be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGroupUsingDELETEWithHttpInfo($name)
    {
        $request = $this->deleteGroupUsingDELETERequest($name);

        return $this->executeRequest($request, Group::class);
    }

    /**
     * Operation deleteGroupUsingDELETEAsync
     *
     * Delete a group
     *
     * @param string $name Name of the group which should be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteGroupUsingDELETEAsync($name)
    {
        return $this->deleteGroupUsingDELETEAsyncWithHttpInfo($name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGroupUsingDELETEAsyncWithHttpInfo
     *
     * Delete a group
     *
     * @param string $name Name of the group which should be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteGroupUsingDELETEAsyncWithHttpInfo($name)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group';
        $request = $this->deleteGroupUsingDELETERequest($name);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation deleteGroupsUsingDELETE
     *
     * Delete multiple groups
     *
     * @param string[] $name List with names of the groups that should be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\Group[]
     */
    public function deleteGroupsUsingDELETE($name)
    {
        list($response) = $this->deleteGroupsUsingDELETEWithHttpInfo($name);

        return $response;
    }

    /**
     * Operation deleteGroupsUsingDELETEWithHttpInfo
     *
     * Delete multiple groups
     *
     * @param string[] $name List with names of the groups that should be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\Group[], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGroupsUsingDELETEWithHttpInfo($name)
    {
        $request = $this->deleteGroupsUsingDELETERequest($name);

        return $this->executeRequest($request, '\Web\FactFinderApi\Client\V3\Model\Group[]');
    }

    /**
     * Operation deleteGroupsUsingDELETEAsync
     *
     * Delete multiple groups
     *
     * @param string[] $name List with names of the groups that should be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteGroupsUsingDELETEAsync($name)
    {
        return $this->deleteGroupsUsingDELETEAsyncWithHttpInfo($name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGroupsUsingDELETEAsyncWithHttpInfo
     *
     * Delete multiple groups
     *
     * @param string[] $name List with names of the groups that should be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteGroupsUsingDELETEAsyncWithHttpInfo($name)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group[]';
        $request = $this->deleteGroupsUsingDELETERequest($name);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation deleteUserUsingDELETE
     *
     * Delete user
     *
     * @param string $username The username of user that will be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\UserNoPassword
     */
    public function deleteUserUsingDELETE($username)
    {
        list($response) = $this->deleteUserUsingDELETEWithHttpInfo($username);

        return $response;
    }

    /**
     * Operation deleteUserUsingDELETEWithHttpInfo
     *
     * Delete user
     *
     * @param string $username The username of user that will be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\UserNoPassword, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserUsingDELETEWithHttpInfo($username)
    {
        $request = $this->deleteUserUsingDELETERequest($username);

        return $this->executeRequest($request, UserNoPassword::class);
    }

    /**
     * Operation deleteUserUsingDELETEAsync
     *
     * Delete user
     *
     * @param string $username The username of user that will be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteUserUsingDELETEAsync($username)
    {
        return $this->deleteUserUsingDELETEAsyncWithHttpInfo($username)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserUsingDELETEAsyncWithHttpInfo
     *
     * Delete user
     *
     * @param string $username The username of user that will be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteUserUsingDELETEAsyncWithHttpInfo($username)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword';
        $request = $this->deleteUserUsingDELETERequest($username);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation deleteUsersUsingDELETE
     *
     * Delete multiple users
     *
     * @param string[] $name The usernames of users that will be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\UserNoPassword[]
     */
    public function deleteUsersUsingDELETE($name)
    {
        list($response) = $this->deleteUsersUsingDELETEWithHttpInfo($name);

        return $response;
    }

    /**
     * Operation deleteUsersUsingDELETEWithHttpInfo
     *
     * Delete multiple users
     *
     * @param string[] $name The usernames of users that will be deleted (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\UserNoPassword[], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUsersUsingDELETEWithHttpInfo($name)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword[]';
        $request = $this->deleteUsersUsingDELETERequest($name);

        return $this->executeRequest($request, $returnType);
    }

    /**
     * Operation deleteUsersUsingDELETEAsync
     *
     * Delete multiple users
     *
     * @param string[] $name The usernames of users that will be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteUsersUsingDELETEAsync($name)
    {
        return $this->deleteUsersUsingDELETEAsyncWithHttpInfo($name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUsersUsingDELETEAsyncWithHttpInfo
     *
     * Delete multiple users
     *
     * @param string[] $name The usernames of users that will be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function deleteUsersUsingDELETEAsyncWithHttpInfo($name)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword[]';
        $request = $this->deleteUsersUsingDELETERequest($name);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation getGroupsUsingGET
     *
     * @param string $name Filter groups whose name contains a specific string (optional)
     * @param string $role Filter groups with specific role (optional)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\Group[]
     */
    public function getGroupsUsingGET($name = null, $role = null)
    {
        list($response) = $this->getGroupsUsingGETWithHttpInfo($name, $role);

        return $response;
    }

    /**
     * Operation getGroupsUsingGETWithHttpInfo
     *
     * @param string $name Filter groups whose name contains a specific string (optional)
     * @param string $role Filter groups with specific role (optional)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\Group[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupsUsingGETWithHttpInfo($name = null, $role = null)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group[]';
        $request = $this->getGroupsUsingGETRequest($name, $role);

        return $this->executeRequest($request, $returnType);
    }

    /**
     * Operation getGroupsUsingGETAsync
     *
     * @param string $name Filter groups whose name contains a specific string (optional)
     * @param string $role Filter groups with specific role (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function getGroupsUsingGETAsync($name = null, $role = null)
    {
        return $this->getGroupsUsingGETAsyncWithHttpInfo($name, $role)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupsUsingGETAsyncWithHttpInfo
     *
     * @param string $name Filter groups whose name contains a specific string (optional)
     * @param string $role Filter groups with specific role (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function getGroupsUsingGETAsyncWithHttpInfo($name = null, $role = null)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group[]';
        $request = $this->getGroupsUsingGETRequest($name, $role);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation getUsersUsingGET
     *
     * @param string $name    Filter users whose name contains a specific string (optional)
     * @param string $role    Filter users with a specific role (optional)
     * @param string $channel Filter users assigned a specific channel (optional)
     * @param string $group   Filter users who are part of a specific group (optional)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\UserNoPassword[]
     */
    public function getUsersUsingGET($name = null, $role = null, $channel = null, $group = null)
    {
        list($response) = $this->getUsersUsingGETWithHttpInfo($name, $role, $channel, $group);

        return $response;
    }

    /**
     * Operation getUsersUsingGETWithHttpInfo
     *
     * @param string $name    Filter users whose name contains a specific string (optional)
     * @param string $role    Filter users with a specific role (optional)
     * @param string $channel Filter users assigned a specific channel (optional)
     * @param string $group   Filter users who are part of a specific group (optional)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\UserNoPassword[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getUsersUsingGETWithHttpInfo($name = null, $role = null, $channel = null, $group = null)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword[]';
        $request = $this->getUsersUsingGETRequest($name, $role, $channel, $group);

        return $this->executeRequest($request, $returnType);
    }

    /**
     * Operation getUsersUsingGETAsync
     *
     * @param string $name    Filter users whose name contains a specific string (optional)
     * @param string $role    Filter users with a specific role (optional)
     * @param string $channel Filter users assigned a specific channel (optional)
     * @param string $group   Filter users who are part of a specific group (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function getUsersUsingGETAsync($name = null, $role = null, $channel = null, $group = null)
    {
        return $this->getUsersUsingGETAsyncWithHttpInfo($name, $role, $channel, $group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUsersUsingGETAsyncWithHttpInfo
     *
     * @param string $name    Filter users whose name contains a specific string (optional)
     * @param string $role    Filter users with a specific role (optional)
     * @param string $channel Filter users assigned a specific channel (optional)
     * @param string $group   Filter users who are part of a specific group (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function getUsersUsingGETAsyncWithHttpInfo($name = null, $role = null, $channel = null, $group = null)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword[]';
        $request = $this->getUsersUsingGETRequest($name, $role, $channel, $group);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation getVisibleChannelsUsingGET
     *
     * Get visible channels
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return string[]
     */
    public function getVisibleChannelsUsingGET()
    {
        list($response) = $this->getVisibleChannelsUsingGETWithHttpInfo();

        return $response;
    }

    /**
     * Operation getVisibleChannelsUsingGETWithHttpInfo
     *
     * Get visible channels
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVisibleChannelsUsingGETWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->getVisibleChannelsUsingGETRequest();

        return $this->executeRequest($request, $returnType);
    }

    /**
     * Operation getVisibleChannelsUsingGETAsync
     *
     * Get visible channels
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function getVisibleChannelsUsingGETAsync()
    {
        return $this->getVisibleChannelsUsingGETAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVisibleChannelsUsingGETAsyncWithHttpInfo
     *
     * Get visible channels
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function getVisibleChannelsUsingGETAsyncWithHttpInfo()
    {
        $returnType = 'string[]';
        $request = $this->getVisibleChannelsUsingGETRequest();

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation updateGroupUsingPUT
     *
     * Update group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\Group
     */
    public function updateGroupUsingPUT($group)
    {
        list($response) = $this->updateGroupUsingPUTWithHttpInfo($group);

        return $response;
    }

    /**
     * Operation updateGroupUsingPUTWithHttpInfo
     *
     * Update group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\Group, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGroupUsingPUTWithHttpInfo($group)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group';
        $request = $this->updateGroupUsingPUTRequest($group);

        return $this->executeRequest($request, $returnType);
    }

    /**
     * Operation updateGroupUsingPUTAsync
     *
     * Update group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function updateGroupUsingPUTAsync($group)
    {
        return $this->updateGroupUsingPUTAsyncWithHttpInfo($group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGroupUsingPUTAsyncWithHttpInfo
     *
     * Update group
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function updateGroupUsingPUTAsyncWithHttpInfo($group)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\Group';
        $request = $this->updateGroupUsingPUTRequest($group);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Operation updateUserUsingPUT
     *
     * Update user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\UserNoRequiredPassword $user user (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return \Web\FactFinderApi\Client\V3\Model\UserNoPassword
     */
    public function updateUserUsingPUT($user)
    {
        list($response) = $this->updateUserUsingPUTWithHttpInfo($user);

        return $response;
    }

    /**
     * Operation updateUserUsingPUTWithHttpInfo
     *
     * Update user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\UserNoRequiredPassword $user user (required)
     *
     * @throws \Web\FactFinderApi\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     *
     * @return array of \Web\FactFinderApi\Client\V3\Model\UserNoPassword, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUserUsingPUTWithHttpInfo($user)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword';
        $request = $this->updateUserUsingPUTRequest($user);

        return $this->executeRequest($request, $returnType);
    }

    /**
     * Operation updateUserUsingPUTAsync
     *
     * Update user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\UserNoRequiredPassword $user user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function updateUserUsingPUTAsync($user)
    {
        return $this->updateUserUsingPUTAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUserUsingPUTAsyncWithHttpInfo
     *
     * Update user
     *
     * @param \Web\FactFinderApi\Client\V3\Model\UserNoRequiredPassword $user user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return \GuzzleHttp6\Promise\PromiseInterface
     */
    public function updateUserUsingPUTAsyncWithHttpInfo($user)
    {
        $returnType = '\Web\FactFinderApi\Client\V3\Model\UserNoPassword';
        $request = $this->updateUserUsingPUTRequest($user);

        return $this->executeAsyncRequest($request, $returnType);
    }

    /**
     * Create request for operation 'createGroupUsingPOST'
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function createGroupUsingPOSTRequest($group)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (\is_array($group) && \count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling createGroupUsingPOST'
            );
        }

        $resourcePath = '/rest/v3/groups';
        $queryParams = [];
        $httpBody = '';
        // body params
        $_tempBody = null;
        if (isset($group)) {
            $_tempBody = $group;
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'createUserUsingPOST'
     *
     * @param \Web\FactFinderApi\Client\V3\Model\User $user user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function createUserUsingPOSTRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (\is_array($user) && \count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling createUserUsingPOST'
            );
        }

        $resourcePath = '/rest/v3/users';
        $queryParams = [];
        $httpBody = '';
        // body params
        $_tempBody = null;
        if (isset($user)) {
            $_tempBody = $user;
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteGroupUsingDELETE'
     *
     * @param string $name Name of the group which should be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function deleteGroupUsingDELETERequest($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (\is_array($name) && \count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteGroupUsingDELETE'
            );
        }

        $resourcePath = '/rest/v3/groups/{name}';
        $queryParams = [];
        $httpBody = '';
        // path params
        if ($name !== null) {
            $resourcePath = \str_replace(
                '{name}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteGroupsUsingDELETE'
     *
     * @param string[] $name List with names of the groups that should be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function deleteGroupsUsingDELETERequest($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (\is_array($name) && \count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteGroupsUsingDELETE'
            );
        }

        $resourcePath = '/rest/v3/groups';
        $queryParams = [];
        $httpBody = '';
        // query params
        if (\is_array($name)) {
            $queryParams['name'] = $name;
        } elseif ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // body params
        $_tempBody = null;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteUserUsingDELETE'
     *
     * @param string $username The username of user that will be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function deleteUserUsingDELETERequest($username)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (\is_array($username) && \count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling deleteUserUsingDELETE'
            );
        }

        $resourcePath = '/rest/v3/users/{username}';
        $queryParams = [];
        $httpBody = '';
        // path params
        if ($username !== null) {
            $resourcePath = \str_replace(
                '{username}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'deleteUsersUsingDELETE'
     *
     * @param string[] $name The usernames of users that will be deleted (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function deleteUsersUsingDELETERequest($name)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (\is_array($name) && \count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteUsersUsingDELETE'
            );
        }

        $resourcePath = '/rest/v3/users';
        $queryParams = [];
        $httpBody = '';
        // query params
        if (\is_array($name)) {
            $queryParams['name'] = $name;
        } elseif ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // body params
        $_tempBody = null;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'getGroupsUsingGET'
     *
     * @param string $name Filter groups whose name contains a specific string (optional)
     * @param string $role Filter groups with specific role (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function getGroupsUsingGETRequest($name = null, $role = null)
    {
        $resourcePath = '/rest/v3/groups';
        $queryParams = [];
        $httpBody = '';
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($role !== null) {
            $queryParams['role'] = ObjectSerializer::toQueryValue($role);
        }

        return $this->getQuery($resourcePath, $queryParams);
    }

    /**
     * Create request for operation 'getUsersUsingGET'
     *
     * @param string $name    Filter users whose name contains a specific string (optional)
     * @param string $role    Filter users with a specific role (optional)
     * @param string $channel Filter users assigned a specific channel (optional)
     * @param string $group   Filter users who are part of a specific group (optional)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function getUsersUsingGETRequest($name = null, $role = null, $channel = null, $group = null)
    {
        $resourcePath = '/rest/v3/users';
        $queryParams = [];
        $httpBody = '';
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($role !== null) {
            $queryParams['role'] = ObjectSerializer::toQueryValue($role);
        }
        // query params
        if ($channel !== null) {
            $queryParams['channel'] = ObjectSerializer::toQueryValue($channel);
        }
        // query params
        if ($group !== null) {
            $queryParams['group'] = ObjectSerializer::toQueryValue($group);
        }

        return $this->getQuery($resourcePath, $queryParams);
    }

    /**
     * Create request for operation 'getVisibleChannelsUsingGET'
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function getVisibleChannelsUsingGETRequest()
    {
        $resourcePath = '/rest/v3/user/channel';
        $queryParams = [];
        $httpBody = '';

        return $this->getQuery($resourcePath, $queryParams);
    }

    /**
     * Create request for operation 'updateGroupUsingPUT'
     *
     * @param \Web\FactFinderApi\Client\V3\Model\Group $group group (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function updateGroupUsingPUTRequest($group)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (\is_array($group) && \count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling updateGroupUsingPUT'
            );
        }

        $resourcePath = '/rest/v3/groups';
        $queryParams = [];
        $httpBody = '';
        // body params
        $_tempBody = null;
        if (isset($group)) {
            $_tempBody = $group;
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create request for operation 'updateUserUsingPUT'
     *
     * @param \Web\FactFinderApi\Client\V3\Model\UserNoRequiredPassword $user user (required)
     *
     * @throws \InvalidArgumentException
     *
     * @return Request
     */
    protected function updateUserUsingPUTRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (\is_array($user) && \count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling updateUserUsingPUT'
            );
        }

        $resourcePath = '/rest/v3/users';
        $queryParams = [];
        $httpBody = '';
        // body params
        $_tempBody = null;
        if (isset($user)) {
            $_tempBody = $user;
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            ['application/json']
        );

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if ($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp6\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if (\is_array($httpBody)) {
                    $httpBody = \GuzzleHttp6\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . \base64_encode($this->config->getUsername() . ':' . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = \array_merge(
            $defaultHeaders,
            $headers
        );

        $query = \GuzzleHttp6\Psr7\build_query($queryParams);

        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     *
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = \fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
