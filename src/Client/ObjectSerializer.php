<?php declare(strict_types=1);
/*
 * FACT-Finder REST API Client
 * Copyright Â© webweit GmbH (https://www.webweit.de)
 */

/**
 * FACT-Finder REST-API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.9
 */

namespace Web\FactFinderApi\Client;

/**
 * ObjectSerializer Class Doc Comment
 *
 * @author   Swagger Codegen team
 *
 * @see     https://github.com/swagger-api/swagger-codegen
 */
class ObjectSerializer
{
    /**
     * Serialize data
     *
     * @param mixed $data the data to serialize
     *
     * @return string|object|array serialized form of $data
     */
    public static function sanitizeForSerialization($data)
    {
        if (\is_scalar($data) || $data === null) {
            return $data;
        } elseif ($data instanceof \DateTime) {
            return /*($format === 'date') ? $data->format('Y-m-d') :*/ $data->format(\DateTime::ATOM);
        } elseif (\is_array($data)) {
            foreach ($data as $property => $value) {
                $data[$property] = self::sanitizeForSerialization($value);
            }

            return $data;
        } elseif ($data instanceof \stdClass) {
            foreach ($data as $property => $value) {
                $data->$property = self::sanitizeForSerialization($value);
            }

            return $data;
        } elseif (\is_object($data)) {
            $values = [];
            foreach ($data::attributeMap() as $property => $externalName) {
                $getter = 'get' . self::camelize($property);
                $value = $data->$getter();
                if ($value !== null) {
                    $values[$externalName] = self::sanitizeForSerialization($value);
                }
            }

            return (object) $values;
        }

        return (string) $data;
    }

    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param string $filename filename to be sanitized
     *
     * @return string the sanitized filename
     */
    public static function sanitizeFilename($filename)
    {
        if (\preg_match("/.*[\/\\\\](.*)$/", $filename, $match)) {
            return $match[1];
        }

        return $filename;
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the path, by url-encoding.
     *
     * @param string $value a string which will be part of the path
     *
     * @return string the serialized object
     */
    public static function toPathValue($value)
    {
        return \rawurlencode(self::toString($value));
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the query, by imploding comma-separated if it's an object.
     * If it's a string, pass through unchanged. It will be url-encoded
     * later.
     *
     * @param string[]|string|\DateTime|bool $object an object to be serialized to a string
     *
     * @return string the serialized object
     */
    public static function toQueryValue($object)
    {
        if (\is_array($object)) {
            return \implode(',', $object);
        }

        if (\is_bool($object)) {
            return $object ? 'true' : 'false';
        }

        return self::toString($object);
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the header. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param string $value a string which will be part of the header
     *
     * @return string the header string
     */
    public static function toHeaderValue($value)
    {
        return self::toString($value);
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the http body (form parameter). If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param string|\SplFileObject $value the value of the form parameter
     *
     * @return string the form string
     */
    public static function toFormValue($value)
    {
        if ($value instanceof \SplFileObject) {
            return $value->getRealPath();
        }

        return self::toString($value);
    }

    /**
     * Take value and turn it into a string suitable for inclusion in
     * the parameter. If it's a string, pass through unchanged
     * If it's a datetime object, format it in ISO8601
     *
     * @param string|\DateTime $value the value of the parameter
     *
     * @return string the header string
     */
    public static function toString($value)
    {
        if ($value instanceof \DateTime) { // datetime in ISO8601 format
            return $value->format(\DateTime::ATOM);
        }

        return $value;
    }

    /**
     * Serialize an array to a string.
     *
     * @param array  $collection                 collection to serialize to a string
     * @param string $collectionFormat           the format use for serialization (csv,
     *                                           ssv, tsv, pipes, multi)
     * @param bool   $allowCollectionFormatMulti allow collection format to be a multidimensional array
     *
     * @return string
     */
    public static function serializeCollection(array $collection, $collectionFormat, $allowCollectionFormatMulti = false)
    {
        if ($allowCollectionFormatMulti && ($collectionFormat === 'multi')) {
            // http_build_query() almost does the job for us. We just
            // need to fix the result of multidimensional arrays.
            return \preg_replace('/%5B[0-9]+%5D=/', '=', \http_build_query($collection, '', '&'));
        }
        switch ($collectionFormat) {
            case 'pipes':
                return \implode('|', $collection);

            case 'tsv':
                return \implode("\t", $collection);

            case 'ssv':
                return \implode(' ', $collection);

            case 'csv':
                // Deliberate fall through. CSV is default format.
            default:
                return \implode(',', $collection);
        }
    }

    /**
     * Deserialize a JSON string into an object
     *
     * @param mixed    $data        object or primitive to be deserialized
     * @param string   $class       class name is passed as a string
     * @param string[] $httpHeaders HTTP headers
     *
     * @return object|array|null an single or an array of $class instances
     */
    public static function deserialize($data, $class, $httpHeaders = null)
    {
        if ($data === null) {
            return null;
        } elseif (\mb_substr($class, 0, 4) === 'map[') { // for associative array e.g. map[string,int]
            $inner = \mb_substr($class, 4, -1);
            $deserialized = [];
            if (\mb_strrpos($inner, ',') !== false) {
                $subClass_array = \explode(',', $inner, 2);
                $subClass = $subClass_array[1];
                foreach ($data as $key => $value) {
                    $deserialized[$key] = self::deserialize($value, $subClass, null);
                }
            }

            return $deserialized;
        } elseif (\strcasecmp(\mb_substr($class, -2), '[]') === 0) {
            $subClass = \mb_substr($class, 0, -2);
            $values = [];
            foreach ($data as $key => $value) {
                $values[] = self::deserialize($value, $subClass, null);
            }

            return $values;
        } elseif ($class === 'object') {
            \settype($data, 'array');

            return $data;
        } elseif ($class === '\DateTime') {
            // Some API's return an invalid, empty string as a
            // date-time property. DateTime::__construct() will return
            // the current time for empty input which is probably not
            // what is meant. The invalid empty string is probably to
            // be interpreted as a missing field/value. Let's handle
            // this graceful.
            if (!empty($data)) {
                return new \DateTime($data);
            }

            return null;
        } elseif (\in_array($class, ['DateTime', 'bool', 'boolean', 'byte', 'double', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'], true)) {
            \settype($data, $class);

            return $data;
        } elseif ($class === '\SplFileObject') {
            /* @var \Psr\Http\Message\StreamInterface $data */

            // determine file name
            if (\array_key_exists('Content-Disposition', $httpHeaders)
                && \preg_match('/inline; filename=[\'"]?([^\'"\s]+)[\'"]?$/i', $httpHeaders['Content-Disposition'], $match)) {
                $filename = \sys_get_temp_dir() . DIRECTORY_SEPARATOR . self::sanitizeFilename($match[1]);
            } else {
                $filename = \tempnam(\sys_get_temp_dir(), '');
            }

            $file = \fopen($filename, 'w');
            while ($chunk = $data->read(200)) {
                \fwrite($file, $chunk);
            }
            \fclose($file);

            return new \SplFileObject($filename, 'r');
        }
        $instance = new $class();
        foreach ($instance::swaggerTypes() as $property => $type) {
            $propertySetter = 'set' . self::camelize($property); //$instance::setters()[$property];

            if (!isset($propertySetter) || !isset($data->{$instance::attributeMap()[$property]})) {
                continue;
            }

            $propertyValue = $data->{$instance::attributeMap()[$property]};
            $instance->$propertySetter(self::deserialize($propertyValue, $type, null));
        }

        return $instance;
    }

    public static function camelize($input, $separator = '_')
    {
        return \str_replace($separator, '', \ucwords($input, $separator));
    }
}
